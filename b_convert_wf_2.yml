name: Build-Publish-Docker

on:
  workflow_dispatch:
    inputs:
      base_tag:
        description: 'Base tag'
        required: false 
        default: 'latest'

permissions:
  contents: read
  packages: write
  id-token: write
  
env:
  BASE_IMAGE: 'fajob' 
  BASE_TAG: ${{ github.event.inputs.base_tag || 'latest' }}
  QUAY: 'registry.cigna.com/cognizant'

jobs:
  build:
    runs-on: Windows-Runner
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Validate Environment Variables
      shell: pwsh
      run: |
        $requiredVars = @('BASE_IMAGE', 'BASE_TAG', 'QUAY')
        $missingVars = @()
        
        foreach ($var in $requiredVars) {
            if (-not (Get-Item env:$var -ErrorAction SilentlyContinue)) {
                $missingVars += $var
            }
        }
        
        if ($missingVars.Count -gt 0) {
            throw "ERROR: Required environment variables not set: $($missingVars -join ', ')"
        }
        
        Write-Output "Environment validation successful"
        Write-Output "BASE_IMAGE: $env:BASE_IMAGE"
        Write-Output "BASE_TAG: $env:BASE_TAG"
        Write-Output "QUAY: $env:QUAY"
    
    - name: Prepare Build Directories
      shell: pwsh
      run: |
        $paths = @(
          "./build/nupkg",
          "./build/bin"
        )
        
        foreach ($path in $paths) {
          if (Test-Path $path) {
            Write-Output "Cleaning existing directory: $path"
            Remove-Item -Path $path -Recurse -Force
          }
          Write-Output "Creating directory: $path"
          New-Item -Path $path -ItemType Directory -Force | Out-Null
        }
    
    - name: Gather and Process Manifests
      shell: pwsh
      run: |
        try {
          $manifestPath = ".\$env:BASE_IMAGE"
          Write-Output "Looking for manifests in: $manifestPath"
          
          if (-not (Test-Path $manifestPath)) {
            throw "Manifest directory not found: $manifestPath"
          }
          
          $files = Get-ChildItem -Path $manifestPath -Recurse -File -Include *manifest.json* -ErrorAction Stop
          if (-not $files) {
            throw "No manifest files found in $manifestPath"
          }
          
          Write-Output "Found $($files.Count) manifest files"
          
          $packages = @{}
          foreach ($file in $files) {
            Write-Output "Processing manifest: $($file.Name)"
            try {
              $content = Get-Content $file.FullName -Raw | ConvertFrom-Json
              foreach ($key in $content.PSObject.Properties.Name) {
                if (-not $packages.ContainsKey($key) -or 
                    [version]$packages[$key].version -lt [version]$content[$key].version) {
                  $packages[$key] = $content[$key]
                  Write-Output "  Added/Updated package: $key (version: $($content[$key].version))"
                }
              }
            }
            catch {
              Write-Warning "Failed to process manifest $($file.Name): $_"
              continue
            }
          }
          
          if ($packages.Count -eq 0) {
            throw "No packages found in manifest files"
          }
          
          Write-Output "Writing $($packages.Count) packages to manifest.json"
          $packages | ConvertTo-Json -Depth 3 | Set-Content './manifest.json' -NoNewline
          Write-Output "Successfully created manifest.json"
        }
        catch {
          Write-Error "Failed to process manifests: $_"
          exit 1
        }
    
    - name: Download and Process Packages
      shell: pwsh
      run: |
        try {
          if (-not (Test-Path './manifest.json')) {
              throw "manifest.json not found. Please ensure the Gather and Process Manifests step completed successfully."
          }
          
          $manifestContent = Get-Content './manifest.json' -Raw
          Write-Output "Manifest content preview: $($manifestContent.Substring(0, [Math]::Min(100, $manifestContent.Length)))..."
          
          $packages = $manifestContent | ConvertFrom-Json
          if (-not $packages -or -not $packages.PSObject.Properties) {
              throw "No packages found in manifest.json or file is empty"
          }
          
          Write-Output "Found $($packages.PSObject.Properties.Count) packages to process"
          
          foreach ($package in $packages.PSObject.Properties) {
            if (-not $package.Value.name -or -not $package.Value.version -or -not $package.Value.build) {
                Write-Warning "Skipping invalid package entry: Missing required properties"
                continue
            }
            
            $name = $package.Value.name
            $version = $package.Value.version
            $build = $package.Value.build
            
            Write-Output "Processing package: $name v$version.$build"
            
            try {
              # Create package URL without authentication
              $packageUrl = "https://cigna.jfrog.io/artifactory/cigna-nuget-lower/Cigna/GBS/Cornerstone/Facets/$name/$name.$version.$build.nupkg"
              $outputPath = "./build/nupkg/temp_$name.zip"
              
              Write-Output "Downloading: $packageUrl"
              
              # Download without authentication headers
              Invoke-WebRequest -Uri $packageUrl -OutFile $outputPath -UseBasicParsing
              
              if (-not (Test-Path $outputPath)) {
                throw "Download failed - output file not created"
              }
              
              $paths = @(
                "./build/nupkg/$name",
                "./build/bin/$name"
              )
              foreach ($path in $paths) {
                New-Item -ItemType Directory -Path $path -Force | Out-Null
              }
              
              Write-Output "Extracting package..."
              Expand-Archive -Path $outputPath -DestinationPath "./build/nupkg/$name" -Force
              
              # Move required files
              $fileTypes = @('*.dll', '*.deps.json', '*.pdb')
              $movedFiles = 0
              foreach ($type in $fileTypes) {
                $files = Get-ChildItem -Path "./build/nupkg/$name" -Filter $type -Recurse
                if ($files) {
                  $files | Move-Item -Destination "./build/bin/$name" -Force
                  $movedFiles += $files.Count
                }
              }
              
              if ($movedFiles -eq 0) {
                Write-Warning "No files were found to move for package: $name"
                continue
              }
              
              Remove-Item -Path $outputPath -Force
              Write-Output "Successfully processed: $name ($movedFiles files)"
            }
            catch {
              Write-Warning "Failed processing $name : $_"
              continue
            }
          }
          
          Write-Output "Package processing completed"
        }
        catch {
          Write-Error "Failed to process packages: $_"
          exit 1
        }
    
    - name: Login to Quay Registry
      uses: docker/login-action@v3
      with:
        registry: registry.cigna.com
        username: ${{ secrets.DEPLOYER_ID }}
        password: ${{ secrets.DEPLOYER_CRED }}
    
    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./${{ env.BASE_IMAGE }}/Dockerfile
        push: true
        tags: |
          ${{ env.QUAY }}/${{ env.BASE_IMAGE }}-base:ext-${{ env.BASE_TAG }}
          ${{ env.QUAY }}/${{ env.BASE_IMAGE }}-base:latest
        build-args: |
          QUAY=${{ env.QUAY }}
          BASE_IMAGE=${{ env.BASE_IMAGE }}-base
          BASE_TAG=${{ env.BASE_TAG }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Clean Up
      if: always()
      shell: pwsh
      run: |
        if (Test-Path ./build) {
          Write-Output "Cleaning up build directory..."
          Remove-Item -Path ./build -Recurse -Force
        }
