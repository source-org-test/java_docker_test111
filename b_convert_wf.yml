name: Build-Publish-Docker

on:
  workflow_dispatch:
    inputs:
      base_tag:
        description: 'Base tag'
        required: false 
        default: 'latest'

permissions:
  contents: read
  packages: write
  id-token: write
  
env:
  BASE_IMAGE: 'fajob' 
  BASE_TAG: ${{ github.event.inputs.base_tag || 'latest' }}
  QUAY: 'registry.cigna.com/cognizant'
  ARTIFACTORY_URL: 'https://cigna.jfrog.io/artifactory'
  NUGET_REPO: 'cigna-nuget-lower/Cigna/GBS/Cornerstone/Facets'

jobs:
  build:
    runs-on: Windows-Runner
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Validate Environment Variables
      shell: pwsh
      run: |
        $requiredVars = @('BASE_IMAGE', 'BASE_TAG', 'QUAY', 'ARTIFACTORY_URL', 'NUGET_REPO')
        $missingVars = @()
        
        foreach ($var in $requiredVars) {
            if (-not (Get-Item env:$var -ErrorAction SilentlyContinue)) {
                $missingVars += $var
            }
        }
        
        if ($missingVars.Count -gt 0) {
            throw "ERROR: Required environment variables not set: $($missingVars -join ', ')"
        }
        
        Write-Output "Environment validation successful"
        Write-Output "BASE_IMAGE: $env:BASE_IMAGE"
        Write-Output "BASE_TAG: $env:BASE_TAG"
        Write-Output "QUAY: $env:QUAY"
    
    - name: Prepare Build Directories
      shell: pwsh
      run: |
        $paths = @(
          "./build/nupkg",
          "./build/bin"
        )
        
        foreach ($path in $paths) {
          if (Test-Path $path) {
            Write-Output "Cleaning existing directory: $path"
            Remove-Item -Path $path -Recurse -Force
          }
          Write-Output "Creating directory: $path"
          New-Item -Path $path -ItemType Directory -Force | Out-Null
        }
    
    - name: Gather and Process Manifests
      shell: pwsh
      run: |
        try {
          $manifestPath = ".\$env:BASE_IMAGE"
          Write-Output "Looking for manifests in: $manifestPath"
          
          if (-not (Test-Path $manifestPath)) {
            throw "Manifest directory not found: $manifestPath"
          }
          
          $files = Get-ChildItem -Path $manifestPath -Recurse -File -Include *manifest.json* -ErrorAction Stop
          if (-not $files) {
            throw "No manifest files found in $manifestPath"
          }
          
          Write-Output "Found $($files.Count) manifest files"
          
          $packages = @{}
          foreach ($file in $files) {
            Write-Output "Processing manifest: $($file.Name)"
            try {
              $content = Get-Content $file.FullName -Raw | ConvertFrom-Json
              foreach ($key in $content.PSObject.Properties.Name) {
                if (-not $packages.ContainsKey($key) -or 
                    [version]$packages[$key].version -lt [version]$content[$key].version) {
                  $packages[$key] = $content[$key]
                  Write-Output "  Added/Updated package: $key (version: $($content[$key].version))"
                }
              }
            }
            catch {
              Write-Warning "Failed to process manifest $($file.Name): $_"
              continue
            }
          }
          
          if ($packages.Count -eq 0) {
            throw "No packages found in manifest files"
          }
          
          Write-Output "Writing $($packages.Count) packages to manifest.json"
          $packages | ConvertTo-Json -Depth 3 | Set-Content './manifest.json' -NoNewline
          Write-Output "Successfully created manifest.json"
        }
        catch {
          Write-Error "Failed to process manifests: $_"
          exit 1
        }
    
    - name: Download and Extract NuGet Packages
      shell: pwsh
      env:
        ARTIFACTORY_TOKEN: ${{ secrets.MY_PACKAGE_TOKEN }}
      run: |
        try {
          if (-not $env:ARTIFACTORY_TOKEN) {
              throw "ARTIFACTORY_TOKEN is not set. Please check the MY_PACKAGE_TOKEN secret is configured."
          }

          # Create headers for Artifactory token authentication
          $headers = @{
            'X-JFrog-Art-Api' = $env:ARTIFACTORY_TOKEN
          }
          
          Write-Output "Authenticating with Artifactory..."
          
          # Test authentication and permissions
          $testUrl = "$env:ARTIFACTORY_URL/api/system/ping"
          try {
              $authResponse = Invoke-WebRequest -Uri $testUrl -Headers $headers -ErrorAction Stop
              Write-Output "Basic authentication successful"
              
              # Test repository access
              $repoTestUrl = "$env:ARTIFACTORY_URL/$env:NUGET_REPO"
              $repoResponse = Invoke-WebRequest -Uri $repoTestUrl -Headers $headers -ErrorAction Stop
              Write-Output "Repository access successful"
          } catch {
              $statusCode = $_.Exception.Response.StatusCode.value__
              $statusDesc = $_.Exception.Response.StatusDescription
              $errorDetails = $_.ErrorDetails.Message
              
              Write-Output "Full error response:"
              Write-Output "Status Code: $statusCode"
              Write-Output "Status Description: $statusDesc"
              Write-Output "Error Details: $errorDetails"
              Write-Output "Request URL: $testUrl"
              
              switch ($statusCode) {
                  401 { throw "Authentication failed: Invalid token. Please check if the token is correct." }
                  403 { throw "Authentication failed: Token lacks necessary permissions. The token needs read permissions for '$env:NUGET_REPO'." }
                  404 { throw "Repository or endpoint not found. Please verify the ARTIFACTORY_URL and NUGET_REPO values." }
                  default { throw "Failed to authenticate: $($_.Exception.Message)" }
              }
          }
          
          if (-not (Test-Path './manifest.json')) {
              throw "manifest.json not found. Please ensure the Gather and Process Manifests step completed successfully."
          }
          
          $manifestContent = Get-Content './manifest.json' -Raw
          Write-Output "Manifest content preview: $($manifestContent.Substring(0, [Math]::Min(100, $manifestContent.Length)))..."
          
          $packages = $manifestContent | ConvertFrom-Json
          if (-not $packages -or -not $packages.PSObject.Properties) {
              throw "No packages found in manifest.json or file is empty"
          }
          
          Write-Output "Found $($packages.PSObject.Properties.Count) packages to process"
          
          foreach ($package in $packages.PSObject.Properties) {
            if (-not $package.Value.name -or -not $package.Value.version -or -not $package.Value.build) {
                Write-Warning "Skipping invalid package entry: Missing required properties"
                continue
            }
            
            $name = $package.Value.name
            $version = $package.Value.version
            $build = $package.Value.build
            
            if ([string]::IsNullOrWhiteSpace($name) -or [string]::IsNullOrWhiteSpace($version) -or [string]::IsNullOrWhiteSpace($build)) {
                Write-Warning "Skipping package with empty values: name='$name' version='$version' build='$build'"
                continue
            }
            
            $url = "$env:ARTIFACTORY_URL/$env:NUGET_REPO/$name/"
            
            Write-Output "Processing package: $name v$version.$build"
            
            try {
              Write-Output "Checking repository access: $url"
              $response = Invoke-WebRequest -Uri $url -Headers $headers -ErrorAction Stop
              
              Write-Output "Searching for package matching pattern: *$version.$build-*"
              $packagePattern = "*$version.$build-*"
              $links = $response.Links | Where-Object { $_.href -like $packagePattern }
              
              if (-not $links) {
                Write-Warning "No matching package found: $name v$version.$build"
                continue
              }
              
              $downloadUrl = "$url$($links[0].href)"
              $outputPath = "./build/nupkg/temp_$name.zip"
              
              Write-Output "Downloading: $downloadUrl"
              Invoke-WebRequest -Uri $downloadUrl -Headers $headers -OutFile $outputPath
              
              if (-not (Test-Path $outputPath)) {
                throw "Download failed - output file not created"
              }
              
              $paths = @(
                "./build/nupkg/$name",
                "./build/bin/$name"
              )
              foreach ($path in $paths) {
                New-Item -ItemType Directory -Path $path -Force | Out-Null
              }
              
              Write-Output "Extracting package..."
              Expand-Archive -Path $outputPath -DestinationPath "./build/nupkg/$name" -Force
              
              # Move required files
              $fileTypes = @('*.dll', '*.deps.json', '*.pdb')
              $movedFiles = 0
              foreach ($type in $fileTypes) {
                $files = Get-ChildItem -Path "./build/nupkg/$name" -Filter $type -Recurse
                if ($files) {
                  $files | Move-Item -Destination "./build/bin/$name" -Force
                  $movedFiles += $files.Count
                }
              }
              
              if ($movedFiles -eq 0) {
                throw "No files were found to move"
              }
              
              Remove-Item -Path $outputPath -Force
              Write-Output "Successfully processed: $name ($movedFiles files)"
            }
            catch {
              if ($_.Exception.Response.StatusCode -eq 401) {
                Write-Error "Authentication failed. Please check your Artifactory token."
                Write-Error "Response: $($_.Exception.Message)"
                exit 1
              }
              elseif ($_.Exception.Response.StatusCode -eq 403) {
                Write-Error "Access denied. Please check if your token has the required permissions."
                Write-Error "Response: $($_.Exception.Message)"
                exit 1
              }
              Write-Error "Failed processing $name : $_"
              if ($_.Exception.Response) {
                Write-Error "Response Status Code: $($_.Exception.Response.StatusCode.value__)"
                Write-Error "Response Status Description: $($_.Exception.Response.StatusDescription)"
              }
              exit 1
            }
          }
        }
        catch {
          Write-Error "Failed to process packages: $_"
          if ($_.Exception.Response) {
            Write-Error "Response Status Code: $($_.Exception.Response.StatusCode.value__)"
            Write-Error "Response Status Description: $($_.Exception.Response.StatusDescription)"
          }
          exit 1
        }
    
    - name: Login to Quay Registry
      uses: docker/login-action@v3
      with:
        registry: registry.cigna.com
        username: ${{ secrets.DEPLOYER_ID }}
        password: ${{ secrets.DEPLOYER_CRED }}
    
    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./${{ env.BASE_IMAGE }}/Dockerfile
        push: true
        tags: |
          ${{ env.QUAY }}/${{ env.BASE_IMAGE }}-base:ext-${{ env.BASE_TAG }}
          ${{ env.QUAY }}/${{ env.BASE_IMAGE }}-base:latest
        build-args: |
          QUAY=${{ env.QUAY }}
          BASE_IMAGE=${{ env.BASE_IMAGE }}-base
          BASE_TAG=${{ env.BASE_TAG }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Clean Up
      if: always()
      shell: pwsh
      run: |
        if (Test-Path ./build) {
          Write-Output "Cleaning up build directory..."
          Remove-Item -Path ./build -Recurse -Force
        }
