name: Build-Publish-Docker

on:
  workflow_dispatch:
    inputs:
      base_tag:
        description: 'Base tag'
        required: false 
        default: 'latest'
      docker_package_version:
        description: 'Version of Dockerfile'
        default: '0.1.0'
        required: false
        type: string

permissions:
  contents: read
  packages: write
  id-token: write
  
env:
  BASE_IMAGE: 'fajob' 
  BASE_TAG: ${{ github.event.inputs.base_tag || 'latest' }}
  QUAY: 'registry.cigna.com/cognizant'
  PACKAGE_VERSION: ''
  PACKAGE_BUILD: ''

jobs:
  build:
    runs-on: Windows-Runner
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    
    - name: Prepare Build Directories
      shell: pwsh
      run: |
        if (Test-Path .\build\bin) { Remove-Item .\build\bin -Recurse -Force }
        if (Test-Path .\build\nupkg) { Remove-Item .\build\nupkg -Recurse -Force }
        New-Item -Path ".\build\nupkg" -ItemType "directory" -Force
        New-Item -Path ".\build\bin" -ItemType "directory" -Force
    
    - name: Gather and Process Manifests
      shell: pwsh
      run: |
        # Helper function to convert PSCustomObject to Hashtable
        function ConvertTo-Hashtable {
            param (
                [Parameter(ValueFromPipeline)]
                $InputObject
            )
            process {
                if ($null -eq $InputObject) { return $null }
                if ($InputObject -is [System.Collections.IEnumerable] -and $InputObject -isnot [string]) {
                    $collection = @(
                        foreach ($object in $InputObject) {
                            ConvertTo-Hashtable $object
                        }
                    )
                    Write-Output -NoEnumerate $collection
                } elseif ($InputObject -is [psobject]) {
                    $hash = @{}
                    foreach ($property in $InputObject.PSObject.Properties) {
                        $hash[$property.Name] = ConvertTo-Hashtable $property.Value
                    }
                    $hash
                } else {
                    $InputObject
                }
            }
        }

        Write-Output "[INFO] Gathering manifests..."
        
        # Get list of manifest files
        $files = $(Get-ChildItem -Path ".\${env:BASE_IMAGE}" -Recurse -File -Include *manifest.json*);
        Write-Output "[INFO] Found $($files.Count) manifest files"
        
        # Translate manifest file content into K,V hashtables
        $content = @();
        For ($i = 0; $i -lt $files.Count; $i++) {
            Write-Output "[INFO] Processing manifest: $($files[$i].Name)"
            $content += $($files[$i] | Get-Content -Raw | ConvertFrom-Json | ConvertTo-Hashtable);
        }
        
        $packages = @{};
        For ($i = 0; $i -lt $content.Count; $i++) {
            # Keys are part of the hashtable and cannot be referenced by index.
            # So we convert them to a list of strings and iterate through that.
            $keys = $content[$i].Keys -as [string[]];
            For ($n = 0; $n -lt $keys.Count; $n++) {
                $value = $content[$i].$($keys[$n]);
                # Compare values for each key and drop lowest
                If (!$packages.ContainsKey($keys[$n])) {
                    Write-Output "[INFO] Adding package: $($keys[$n]) (version: $($value.version), build: $($value.build))"
                    $packages.Add($keys[$n], $value);
                }
                ElseIf ($packages.$($keys[$n]).version -lt $value.version) {
                    Write-Output "[INFO] Updating package: $($keys[$n]) (new version: $($value.version), build: $($value.build))"
                    $packages.$($keys[$n]) = $value;
                }
                ElseIf (($packages.$($keys[$n]).version -eq $value.version) -and (($packages.$($keys[$n]).build -lt $value.build -and $packages.$($keys[$n]).build -ne 'latest') -or $value.build -eq 'latest')) {
                    Write-Output "[INFO] Updating package: $($keys[$n]) (same version, new build: $($value.build))"
                    $packages.$($keys[$n]) = $value;            
                }
            }
        }
        
        Write-Output "[INFO] Writing manifest with $($packages.Count) packages"
        $packages | ConvertTo-Json | Out-File -FilePath './manifest.json' -NoNewline -Force;
        
        # Set package version and build for later use
        $keys = $packages.Keys -as [string[]];
        For ($i = 0; $i -lt $keys.Count; $i++) {
            $name = $packages.$($keys[$i]).name
            if($name -eq "PACKAGE") { 
                "PACKAGE_VERSION=$($packages[$keys[$i]].version)" >> $env:GITHUB_ENV
                "PACKAGE_BUILD=$($packages[$keys[$i]].build)" >> $env:GITHUB_ENV
                Write-Output "[INFO] Set package version: $($packages[$keys[$i]].version)"
                break
            }
        }
    
    - name: Download and Process Packages
      shell: pwsh
      run: |
        Write-Output "[INFO] Fetching NuGet Packages..."
        
        # Create error log directory
        New-Item -ItemType Directory -Path ".\logs" -Force | Out-Null
        
        $packages = Get-Content './manifest.json' -Raw | ConvertFrom-Json
        $keys = $packages.PSObject.Properties.Name
        $hasErrors = $false
        $package_version = ""
        $package_build = ""
        
        foreach ($key in $keys) {
            $name = $packages.$key.name
            if($name -eq "PACKAGE") { 
                $package_version = $packages.$key.version
                $package_build = $packages.$key.build
                Write-Output "package version $package_version"
                continue
            }
            
            $version = $packages.$key.version
            $build = $packages.$key.build
            
            Write-Output "[INFO] Processing $key (version: $version, build: $build)"
            
            try {
                # Construct the complete URL for the specific package and version
                $targetVersion = "$version.$build"
                $packageName = $key
                
                # Build the complete NuGet package URL directly
                # This format matches standard NuGet package URL patterns
                $packageUrl = "https://cigna.jfrog.io/artifactory/cigna-nuget-lower/Cigna/GBS/Cornerstone/Facets/$packageName/$packageName.$targetVersion.nupkg"
                Write-Output "[INFO] Checking: $packageUrl"
                
                try {
                    # Try to download the package directly with the constructed URL
                    $outputPath = ".\build\nupkg\$packageName.$targetVersion.nupkg"
                    
                    # Create directories
                    New-Item -ItemType Directory -Path ".\build\nupkg\$name" -Force | Out-Null
                    New-Item -ItemType Directory -Path ".\build\bin\$name" -Force | Out-Null
                    
                    # Download the package directly
                    Write-Output "Downloading $packageUrl..."
                    Invoke-WebRequest -Uri $packageUrl -OutFile $outputPath -UseBasicParsing
                    
                    if (Test-Path $outputPath) {
                        # Extract the package
                        Write-Output "Directory: `n$(Get-Location)\build\nupkg"
                        Get-ChildItem -Path ".\build\nupkg" -Directory | Format-Table
                        
                        # Extract the nupkg (which is a zip file)
                        Add-Type -AssemblyName System.IO.Compression.FileSystem
                        [System.IO.Compression.ZipFile]::ExtractToDirectory($outputPath, ".\build\nupkg\$name")
                        
                        Write-Output "Directory: $(Get-Location)\build\bin"
                        Get-ChildItem -Path ".\build\bin" -Directory | Format-Table
                        
                        # Move DLL files to bin directory
                        Write-Output "Directory: `n$(Get-Location)\build\bin\$name"
                        Get-ChildItem -Path ".\build\nupkg\$name" -Filter "*.dll" -Recurse | 
                            Move-Item -Destination ".\build\bin\$name" -Force
                            
                        # List the files in the bin directory
                        Get-ChildItem -Path ".\build\bin\$name" | Format-Table Mode, LastWriteTime, Length, Name
                        
                        # Cleanup
                        Remove-Item -Path $outputPath -Force
                    } else {
                        throw "Download failed - output file not created"
                    }
                } catch {
                    # If direct package URL fails, try alternate URL formats
                    Write-Output "[INFO] Direct package URL failed, attempting to find package with alternate URL patterns..."
                    
                    # Try different NuGet package naming patterns
                    $alternateUrls = @(
                        "https://cigna.jfrog.io/artifactory/cigna-nuget-lower/Cigna/GBS/Cornerstone/Facets/$packageName/$packageName.$version.$build.nupkg",
                        "https://cigna.jfrog.io/artifactory/cigna-nuget-lower/Cigna/GBS/Cornerstone/Facets/$packageName/${packageName}.$version.$build.zip",
                        "https://cigna.jfrog.io/artifactory/cigna-nuget-lower/Cigna/GBS/Cornerstone/Facets/$packageName/${packageName}.$version.$build-full.nupkg"
                    )
                    
                    $downloaded = $false
                    foreach ($altUrl in $alternateUrls) {
                        try {
                            Write-Output "[INFO] Trying alternate URL: $altUrl"
                            $fileName = [System.IO.Path]::GetFileName($altUrl)
                            $outputPath = ".\build\nupkg\$fileName"
                            
                            Invoke-WebRequest -Uri $altUrl -OutFile $outputPath -UseBasicParsing -ErrorAction Stop
                            
                            if (Test-Path $outputPath) {
                                Write-Output "[INFO] Successfully downloaded using alternate URL!"
                                
                                # Extract the package
                                Add-Type -AssemblyName System.IO.Compression.FileSystem
                                [System.IO.Compression.ZipFile]::ExtractToDirectory($outputPath, ".\build\nupkg\$name")
                                
                                # Move DLL files to bin directory
                                Get-ChildItem -Path ".\build\nupkg\$name" -Filter "*.dll" -Recurse | 
                                    Move-Item -Destination ".\build\bin\$name" -Force
                                    
                                # List the files in the bin directory
                                Get-ChildItem -Path ".\build\bin\$name" | Format-Table Mode, LastWriteTime, Length, Name
                                
                                # Cleanup
                                Remove-Item -Path $outputPath -Force
                                
                                $downloaded = $true
                                break
                            }
                        } catch {
                            Write-Output "[INFO] Alternate URL failed: $altUrl"
                            continue
                        }
                    }
                    
                    if (-not $downloaded) {
                        # If all attempts fail, throw an error
                        $errorMessage = "[ERROR] Failed to download package $packageName (version: $version, build: $build)"
                        $errorMessage += "`nTried multiple URL formats but none succeeded"
                        $errorMessage += "`nCheck if the package exists and you have the correct version information"
                        $errorMessage += "`nError details: $_"
                        
                        Write-Error $errorMessage
                        $errorMessage | Out-File ".\logs\${key}_error.log" -Append
                        $hasErrors = $true
                    }
                }
            }
            catch {
                $errorMessage = "[ERROR] Failed processing $key :`n$_"
                Write-Error $errorMessage
                $errorMessage | Out-File ".\logs\${key}_error.log" -Append
                $hasErrors = $true
                continue
            }
        }
        
        if ($hasErrors) {
            Write-Output "[INFO] Errors occurred during package processing. Check logs directory for details."
            Get-ChildItem -Path ".\logs" -Filter "*_error.log" | ForEach-Object {
                Write-Output "`nErrors for $($_.BaseName):"
                Get-Content $_.FullName | ForEach-Object { Write-Output "  $_" }
            }
            exit 1
        }

    - name: Build Docker Image
      shell: pwsh
      run: |
        Write-Output "[INFO] Building Docker image..."
        $imageTag = "ext-${env:BASE_TAG}-${env:PACKAGE_VERSION}"
        $imageName = "${env:QUAY}/${env:BASE_IMAGE}-base"
        
        docker build --pull . -f .\${env:BASE_IMAGE}\Dockerfile `
          -t ${imageName}:${imageTag} `
          --no-cache `
          --build-arg QUAY=${env:QUAY} `
          --build-arg BASE_IMAGE=${env:BASE_IMAGE}-base `
          --build-arg BASE_TAG=${env:BASE_TAG}
        
        if ($LASTEXITCODE -ne 0) {
            Write-Error "[ERROR] Docker build failed"
            exit 1
        }
        
        Write-Output "[INFO] Successfully built image: ${imageName}:${imageTag}"

    - name: Login to Registry
      shell: pwsh
      env:
        DEPLOYER_ID: ${{ secrets.DEPLOYER_ID }}
        DEPLOYER_CRED: ${{ secrets.DEPLOYER_CRED }}
      run: |
        Write-Output "[INFO] Logging into registry..."
        docker login -u $env:DEPLOYER_ID -p $env:DEPLOYER_CRED registry.cigna.com
        if ($LASTEXITCODE -ne 0) {
            Write-Error "[ERROR] Docker login failed"
            exit 1
        }

    - name: Push Docker Image
      shell: pwsh
      run: |
        $imageTag = "ext-${env:BASE_TAG}-${env:PACKAGE_VERSION}"
        $imageName = "${env:QUAY}/${env:BASE_IMAGE}-base"
        
        Write-Output "[INFO] Pushing image: ${imageName}:${imageTag}"
        docker push ${imageName}:${imageTag}
        if ($LASTEXITCODE -ne 0) {
            Write-Error "[ERROR] Failed to push image: ${imageTag}"
            exit 1
        }
        
        Write-Output "[INFO] Tagging as latest..."
        docker tag ${imageName}:${imageTag} ${imageName}:latest
        
        Write-Output "[INFO] Pushing latest tag..."
        docker push ${imageName}:latest
        if ($LASTEXITCODE -ne 0) {
            Write-Error "[ERROR] Failed to push latest tag"
            exit 1
        }
        
        Write-Output "[INFO] Successfully pushed all tags"

    - name: Cleanup
      if: always()
      shell: pwsh
      run: |
        Write-Output "[INFO] Cleaning up build directory..."
        if (Test-Path .\build) {
            Remove-Item .\build -Recurse -Force
        }
